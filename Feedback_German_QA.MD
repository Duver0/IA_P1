# üìä AUDITOR√çA CRUZADA AI-FIRST: RESERVAS SOFKA
## Code Review Aumentado por IA - Evaluaci√≥n seg√∫n R√∫brica Sofka

**Fecha**: 13 de febrero de 2026  
**Equipo Auditor**: AI-Assisted Review Team (German Rojas & Antigravity)  
**Proyecto Auditado**: reservasSofka  
**Contexto Taller**: Microservicios con Producer/Consumer/Broker (RabbitMQ)  

---

## üåø Rama de auditor√≠a (QA Review)

- **Rama (local):** `review/team-three-Qa`
- **Rama (remota):** (pendiente)
- **PR hacia `develop`:** (pendiente)


---

## ‚úÖ Evidencia: Run & Break (docker compose)

**Objetivo:** Validar que el proyecto levanta correctamente con Docker y que los servicios se comunican sin intervenci√≥n manual.

**Comandos ejecutados:**
- `docker compose up --build`
- (opcional) `docker compose ps`
- (opcional) `docker compose logs -f`

**Resultado:**
- ‚úÖ El stack levanta correctamente.
- ‚úÖ No se presentaron errores bloqueantes durante el arranque.
- ‚úÖ El flujo funcional principal se puede ejecutar y el proyecto opera de acuerdo con el README.

**Notas QA:**
- Se recomienda mantener esta prueba como ‚Äúsmoke test‚Äù obligatorio antes de merge a `develop`.

---
## 1. Estrategia de IA (AI_WORKFLOW.md) Opinion de Antigravity
**Calificaci√≥n: 5 - Excelente üöÄ**

El archivo `AI_WORKFLOW.md` es un documento vivo y detallado. Cumple con todos los criterios de la metodolog√≠a AI-First:
- Define claramente los roles ("AI as Junior Developer", "Human as Architect").
- Establece un protocolo de interacci√≥n y revisi√≥n.
- Incluye la secci√≥n de "Sentinel Comments" explicando el uso de `// üõ°Ô∏è HUMAN CHECK`.
- Define din√°micas de interacci√≥n y CSS guidelines.
- Es un excelente ejemplo de documentaci√≥n de procesos con IA.



## 1. Estrategia de IA (AI_WORKFLOW.md) Opinion de German
**Calificaci√≥n: 3 - Aceptable üòê (Gen√©rico, falta evidencia)**

El archivo `AI_WORKFLOW.md` **explica la intenci√≥n** del enfoque AI-First y lista etapas del proceso (uso de IA, revisi√≥n humana, validaci√≥n, etc.), pero actualmente se queda en un nivel **descriptivo** y **no auditable**: no demuestra con evidencia *c√≥mo* se aplic√≥ realmente en este repo ni deja una gu√≠a replicable para otro equipo.

### Observaciones clave (QA)
- **Falta trazabilidad:** no incluye referencias a commits/PRs, decisiones verificables o ejemplos reales (ruta de archivo + snippet) que soporten lo descrito.
- **Prompts inexistentes o vagos:** no presenta prompts reales (ni variaciones), por lo que no se entiende la estrategia de interacci√≥n con IA ni c√≥mo iteraron cuando fall√≥.
- **HUMAN CHECK sin muestras:** menciona revisi√≥n humana, pero no evidencia ‚ÄúSentinel Comments‚Äù reales (`// üõ°Ô∏è HUMAN CHECK`) ni criterios de aceptaci√≥n aplicados.
   - El equipo s√≠ aplic√≥ la pr√°ctica, pero fall√≥ la documentaci√≥n del proceso (AI_WORKFLOW qued√≥ incompleto / gen√©rico).
- **‚ÄúLo que la IA hizo mal‚Äù sin m√©todo:** lista fallos t√≠picos, pero no muestra el patr√≥n de detecci√≥n ‚Üí fix ‚Üí prevenci√≥n (reglas, checklist, automatizaci√≥n).

### Recomendaci√≥n m√≠nima para cumplir r√∫brica
1. **Secci√≥n ‚ÄúPrompts usados‚Äù (5+)**: objetivo, prompt, resultado, y ajuste aplicado (iteraci√≥n 1 ‚Üí iteraci√≥n 2).  
2. **Secci√≥n ‚ÄúEvidencia / trazabilidad‚Äù**: links o referencias a commits/PRs + resumen de qu√© se corrigi√≥ gracias a IA vs revisi√≥n humana.  
3. **3‚Äì5 ejemplos reales de `// üõ°Ô∏è HUMAN CHECK`** con **ruta de archivo**, contexto y decisi√≥n (seguridad, docker/infra, mensajer√≠a, l√≥gica de negocio).  
4. **Tabla ‚ÄúLo que la IA hizo mal‚Äù** con columnas: *Problema* ‚Üí *C√≥mo se detect√≥* ‚Üí *Fix aplicado* ‚Üí *Prevenci√≥n (regla/checklist/test)*.

### Conclusi√≥n (Paso 1)
El documento funciona como introducci√≥n, pero **no alcanza el est√°ndar AI-First** esperado por la r√∫brica porque no deja evidencia ni un workflow replicable. Con los ajustes propuestos, puede convertirse en un ‚Äúdocumento vivo‚Äù realmente √∫til para auditor√≠a y transferencia de aprendizaje.

## 2. Calidad del C√≥digo & HUMAN CHECK
**Calificaci√≥n: 5 - Excelente üöÄ**

El c√≥digo auditado demuestra un alto est√°ndar de calidad y un uso excepcional de la metodolog√≠a de revisi√≥n humana.
- **Sentinel Comments:** Se encontraron **35 instancias** de `// üõ°Ô∏è HUMAN CHECK` documentando decisiones cr√≠ticas.
- **Calidad de los comentarios:** No son triviales. Cubren temas complejos como:
    - **Race Conditions:** `TurnosService.asignarConsultorio` explica c√≥mo evita condiciones de carrera.
    - **Performance:** `SchedulerService` advierte sobre los l√≠mites de `@Interval`.
    - **Seguridad:** `docker-compose.yml` advierte sobre credenciales por defecto.
    - **L√≥gica de Negocio:** `TurnosService.findPacientesEnEspera` justifica el ordenamiento en memoria.

## 3. Transparencia ("Lo que la IA hizo mal")
**Calificaci√≥n: 3 - Aceptable üòê**

El `README.md` incluye una secci√≥n llamada **"üìù Notas de Auditor√≠a (Fixes recientes)"** que lista correcciones importantes (Type Safety, Race Conditions, Docker Networking).
- **Por mejorar:** La r√∫brica exige expl√≠citamente el t√≠tulo **"Lo que la IA hizo mal"**. Aunque el contenido es t√©cnicamente correcto y honesto, se debe ajustar el t√≠tulo para cumplir con el requisito de "Anti-Pattern Log" y hacerlo m√°s visible como lecciones aprendidas de errores de la IA, no solo como "fixes".

## 4. Arquitectura & Docker
**Calificaci√≥n: 4 -  Bueno üöÄ**

La arquitectura es robusta y sigue los principios de microservicios.
- **Puntos Fuertes:**
    - `docker-compose.yml` bien estructurado con redes y vol√∫menes.
    - Uso extensivo de variables de entorno con valores por defecto documentados.
    - Contenedores nombreados y separados por responsabilidad.
- **Oportunidad de Mejora:**
    - Faltan `healthchecks` en `producer` y `consumer` para asegurar que esperen a que RabbitMQ y Mongo est√©n **realmente listos** antes de iniciar, m√°s all√° del `depends_on` (que solo espera al inicio del contenedor).

## 5. Git Flow & Colaboraci√≥n
**Calificaci√≥n: 4 -  Bueno üöÄ**

Se evidencia una estructura de ramas (`main`, `team-three`, `review` folder) sugiriendo trabajo paralelo.
- El proyecto tiene una estructura clara.
- pero se considera manejar mas ramas segun los features a desarrollar, co
- Se recomienda asegurar que `main` est√© protegido y que todo pase por PRs desde ramas `feature/*` o `team-*`.

**‚úÖ Versi√≥n equilibrada (recomendada)**
- Aunque el repositorio tiene main y develop, y existen algunas ramas feature/*, el uso de ramas por funcionalidad no parece consistente. Esto puede indicar que parte del desarrollo se integr√≥ directamente en ramas principales (o que el equipo trabaj√≥ en cambios grandes sin dividir en features), lo cual aumenta el riesgo de conflictos, dificulta el code review y reduce la trazabilidad por entrega.

---

## üèÜ Bonus Challenge: "El Detector de Alucinaciones"
### Optimizaci√≥n AI-First

**Hallazgo:** Ineficiencia en `SchedulerService` (Backend Consumer).

**Ubicaci√≥n:** `backend/consumer/src/scheduler/scheduler.service.ts`

**Problema Detectado:**
Dentro del m√©todo `handleSchedulerTick`, que se ejecuta **cada segundo**, se genera un nuevo array de strings para representar los consultorios:
```typescript
// L√≠nea 57-60
const todosConsultorios = Array.from(
    { length: this.totalConsultorios },
    (_, i) => String(i + 1),
);
```
Esto crea objetos innecesarios en el Heap en cada ciclo del scheduler (frecuencia alta), lo cual es ineficiente y aumenta la presi√≥n sobre el Garbage Collector.

**Propuesta de Optimizaci√≥n:**
Mover la generaci√≥n de `todosConsultorios` al constructor o a una propiedad de la clase, ya que `totalConsultorios` es constante durante la vida del servicio.

**C√≥digo Optimizado:**

```typescript
@Injectable()
export class SchedulerService {
    // ...
    private readonly todosConsultorios: string[]; // Propiedad de clase

    constructor(...) {
        this.totalConsultorios = Number(process.env.CONSULTORIOS_TOTAL) || DEFAULT_CONSULTORIOS;

        // Optimizaci√≥n: Generar el array una sola vez al inicio
        this.todosConsultorios = Array.from(
            { length: this.totalConsultorios },
            (_, i) => String(i + 1),
        );
    }

    @Interval(SCHEDULER_INTERVAL_MS)
    async handleSchedulerTick(): Promise<void> {
        // ...
        // Usar la propiedad pre-calculada
        const libres = this.todosConsultorios.filter(c => !ocupados.includes(c));
        // ...
    }
}
```

**Impacto Cuantificable (M√©trica Z%):**
- **Reducci√≥n de asignaciones en el hot path:** **100%** para la creaci√≥n de `todosConsultorios` en cada tick.
  - Antes: se creaba `todosConsultorios` en cada ejecuci√≥n de `handleSchedulerTick` (cada 1s).
  - Despu√©s: se precalcula una sola vez en el constructor y se reutiliza.

- **Objetos evitados (por frecuencia 1 Hz):**
  - **Por tick:** se evita crear **1 array + N strings** (donde `N = totalConsultorios`).
  - **Por minuto:** **60 arrays + 60√óN strings** evitados.
  - **Por hora:** **3600 arrays + 3600√óN strings** evitados.

- **Efecto esperado:** se elimina trabajo repetitivo (incluida la conversi√≥n `String(i + 1)`) en un m√©todo de alta frecuencia, reduciendo presi√≥n de CPU/GC en el ‚Äúhot path‚Äù.


---

## üöÄ Mejoras Futuras y Estrategia de Pruebas

**Recomendaci√≥n:** Para asegurar la fiabilidad del sistema y cumplir con los est√°ndares AI-First, se recomienda implementar Pruebas Unitarias para el **Consumer** (L√≥gica del Scheduler) y el **Frontend** (Componentes Clave).

### üìÇ Estructura de Pruebas Recomendada
Hemos creado archivos de prueba de ejemplo en `refactor/fix/docs` que deben moverse a sus directorios fuente respectivos:

1.  **Backend Consumer (Scheduler)**:
    *   Ubicaci√≥n Actual: `refactor/fix/docs/scheduler.service.spec.ts`
    *   **Ubicaci√≥n Objetivo:** `backend/consumer/src/scheduler/scheduler.service.spec.ts`
    *   *Prop√≥sito:* Validar la l√≥gica de asignaci√≥n de turnos y manejo de consultorios libres/ocupados.

2.  **Frontend (P√°gina Principal)**:
    *   Ubicaci√≥n Actual: `refactor/fix/docs/HomePage.test.tsx`
    *   **Ubicaci√≥n Objetivo:** `frontend/src/app/page.test.tsx`
    *   *Prop√≥sito:* Validar que la p√°gina principal renderice correctamente y se conecte al WebSocket.

### üß™ Ejemplo: Snippet de Prueba Unitaria Frontend
```typescript
// Ejemplo de refactor/fix/docs/HomePage.test.tsx
describe('Home Page', () => {
    it('renders the title', () => {
        render(<Home />);
        const title = screen.getByText(/Turnos M√©dicos/i);
        expect(title).toBeInTheDocument();
    });
});
```

Para ejecutar estas pruebas, necesitar√°s agregar la configuraci√≥n de `jest` a los archivos `package.json` respectivos.


---

### ‚úÖ Conclusi√≥n
El proyecto **reservasSofka** es un excelente ejemplo de aplicaci√≥n de la metodolog√≠a AI-First. El equipo ha demostrado no solo capacidad t√©cnica para construir microservicios, sino una madurez notable para auditar y corregir a la IA en puntos cr√≠ticos de seguridad y concurrencia.
